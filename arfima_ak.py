# -*- coding: utf-8 -*-
# -------------------------------

# @product：PyCharm

# -------------------------------

# @filename：arfima_ak.py
# @teim：2025/11/1 10:36

# @email：2301110293@pku.edu.cn

# -------------------------------
from collections.abc import Iterable
import dask
import dask.array as da
import numpy as np
import numba
import scipy.ndimage as sn
from scipy.fft import fft, ifft
from scipy.stats import levy_stable, norm

def convolve_func(block, kernel):
    return sn.convolve1d(block, kernel, mode='constant')

def arfima_da(
        n: int,
        phi: list[float] = 0,  # ar_params
        theta: list[float] = [],  # ma_params
        dfrac: float = 0,  # frac_diff_params
        dint: int = 0,
        std: float = 1,
        mean: float = 0,
        alpha: float = 2,
        size: tuple[int] = (),
        warmup: int = 500, **kwargs,
) -> np.ndarray:
    """Generate series from ARFIMA process.

    Args:
        n: int
            Number of points to generate.
        phi: list[float]
            Coefficients to be used by the AR process.(ar_params)
        theta: list[float]
            Coefficients to be used by the MA process.(ma_params)
        dfrac: float
            Fractional differentiation order used by the ARFIMA process.(default: 0).
        dint: float
            Integer differentiation order used by the ARFIMA process.(default: 0).
        std: float, optional
            Scale of the generated noise (default: 1).
        mean: float, optional
            mean of the generated noise (default: 1).
        alpha: float, optional
            Parameter of the alpha-stable distribution (default: 2). Default
            value corresponds to Gaussian distribution.
        size : int, optional
            Parameter of the Noise shape (N,). (Default ())

        warmup: int, optional
            Number of points to generate as a warmup for the model
            (default: 0).

    Returns:
        Discrete series (array of length n_points) generated by the
        ARFIMA(len(ar_params), d, len(ma_params)) process.
    """

    if isinstance(phi, Iterable):
        phi = np.array(phi)
    elif isinstance(phi, float) or isinstance(phi, int):
        if phi == 0:
            phi = np.array([])
        else:
            phi = np.array([phi])
    if isinstance(theta, Iterable):
        theta = np.array(theta)
    elif isinstance(theta, float) or isinstance(theta, int):
        if theta == 0:
            theta = np.array([])
        else:
            theta = np.array([theta])
    if isinstance(size, int):
        if size == 0:
            size = ()
        else:
            size = (size,)


    result_type = kwargs.pop('result', 'normal')

    ma_order = len(theta)
    n0 = n + warmup
    noise = __noise_da(n0 + ma_order, std=std, mean=mean, alpha=alpha, size=size)



    if ma_order == 0:
        ma_series = noise
    else:
        ma_coeffs = np.append([1], theta)
        if (ma_order + 1) % 2 == 0:
            start = (ma_order) // 2
            end = n0 + ma_order - (start + 1)
        else:
            start = (ma_order) // 2
            end = n0 + ma_order - start
        ma_series = __ma_model_da(ma_coeffs=ma_coeffs, noise=noise)[..., start:end]

    if dfrac == 0 and dint == 0:
        frac_ma = ma_series
    else:
        frac_ma = __frac_diff_da(ma_series, dfrac=dfrac, dint=dint)
    frac_ma = frac_ma.compute()

    if np.count_nonzero(phi) == 0:
        series = frac_ma.swapaxes(0, -1)
    else:
        series = __arma_model_jit(phi=phi, noise=frac_ma)



    if result_type == 'all':
        result_dict = {}
        result_dict['series'] = series[warmup:]
        result_dict['series_'] = series
        result_dict['noise'] = noise
        result_dict['ma_series'] = ma_series
        result_dict['frac_ma'] = frac_ma
        return result_dict
    else:
        return series[warmup:]


def __noise_da(n,
               std: float = 1,
               mean: float = 0,
               alpha: float = 2,
               size: tuple[int] = (), ):
    """Generate discrete series using MA process.

        Args:
            n: int
                Number of points to generate.
            theta: list[float]
                Coefficients used by the MA process:
                    x[t] = epsi[t] + params[1]*epsi[t-1] + params[2]*epsi[t-2] + ...
                Order of the MA process is inferred from the length of this array.
            std: float, optional
                Scale of the generated noise (default: 1).
            mean: float, optional
                Mean of the generated noise (default: 0).
            alpha: float, optional
                Parameter of the alpha-stable distribution (default: 2). Default
                value corresponds to Gaussian distribution.
        Returns:
            Discrete noise series (array of length n) generated
        """
    if alpha == 2:
        noise = da.random.normal(loc=mean, scale=std,
                                 size=(*size, n))  # norm.rvs(scale=std, size=(n + theta))
    else:
        noise = levy_stable.rvs(
            alpha, 0, scale=std, size=(*size, n)
        )
        noise = da.from_array(noise)
    return noise


def __ma_model_da(ma_coeffs, noise
                  ) -> da.array:
    """Generate discrete series using MA process.

    Args:
        ma_coeffs: list[float],array
            Coefficients used by the MA process:
                x[t] = epsi[t] + params[1]*epsi[t-1] + params[2]*epsi[t-2] + ...
            Order of the MA process is inferred from the length of this array.
        std: float, optional
            Scale of the generated noise (default: 1).
        noise: da.array
            noise (default: white noise).
    Returns:
        Discrete series (array of length n) generated by
        MA(len(params)) process
    """
    kernel = ma_coeffs[::-1]
    ma_series = noise.map_blocks(convolve_func, kernel, dtype=noise.dtype)
    # ma_series = sn.convolve1d(noise,ma_coeffs[::-1],axis=axis)[...,start:end]
    return ma_series


def __frac_diff_da(x: da.array, dfrac: float, dint: int) -> da.array:
    """Fast fractional difference algorithm (by Jensen & Nielsen (2014)).

    Args:
        x: da.array[float]
            Array of values to be differentiated.
        dfrac: float
            Fractional Order of the differentiation. Recommend to use -0.5 < d < 0.5, but
            should work for almost any reasonable d.
        dint: float
            Integer differentiation order used by the ARFIMA process.(default: 0).
    Returns:
        Fractionally differentiated series.
    """
    d = -(dfrac + dint)

    from dask.array.fft import fft, ifft
    def next_pow2(n):
        # we assume that the input will always be n > 1,
        # so this brief calculation should be fine
        return (n - 1).bit_length()

    x = x.rechunk({-1: -1, 0: 'auto'})
    n = x.shape[-1]
    fft_len = 2 ** next_pow2(2 * n - 1)
    prod_ids = np.arange(1, n)
    frac_diff_coefs = np.append([1], np.cumprod((prod_ids - d - 1) / prod_ids))
    frac_diff_coefs = da.from_array(frac_diff_coefs)
    dx = ifft(fft(x, fft_len) * fft(frac_diff_coefs, fft_len))
    return da.real(dx[..., 0:n])


@numba.njit()
def __arma_model_jit(phi: np.ndarray, noise: np.ndarray) -> np.ndarray:
    """Generate discrete series using ARMA process.

    Args:
        phi: list[float]
            Coefficients used by the AR process:
                x[t] = params[1]*x[t-1] + params[2]*x[t-2] + ... + epsi[t]
            Order of the AR process is inferred from the length of this array.
        noise: list[float]
            Values of the noise for each step. Length of the output array is
            automatically inferred from the length of this array. Note that
            noise needs not to be standard Gaussian noise (MA(0) process). It
            may be also generated by a higher order MA process.

    Returns:
        Discrete series (array of the same length as noise array) generated by
        the ARMA(len(params), ?) process.
    """
    ar_order = len(phi)
    n = noise.shape[-1]
    size = noise.shape[:-1]
    kernel = phi[::-1]
    arma_series = np.zeros((n + ar_order, *size))
    for idx in range(ar_order, len(arma_series)):
        temp = noise[..., idx - ar_order]
        for idx_ in range(ar_order):
            temp += kernel[idx_] * arma_series[idx - ar_order + idx_]
        arma_series[idx] = temp
    return arma_series[ar_order:]


def standard(X, axis=0):
    return (X - X.mean(axis=axis, keepdims=True)) / X.std(axis=axis, keepdims=True)
